EOF: int;
buf: *int;
nbuf: int;

// ==================== STD ====================
isspace: (c: int) -> bool = {
    return c == 10 || c == 32;
}

isascii: (c: int) -> bool = {
    return c <= 127;
}

isalpha: (c: int) -> bool = {
    if (!isascii(c)) {
        return false;
    }
    if (cast(int, 'A') <= c && c <= cast(int, 'Z')) {
        return true;
    }
    if (cast(int, 'a') <= c && c <= cast(int, 'z')) {
        return true;
    }
    return false;
}

isdigit: (c: int) -> bool = {
    if (!isascii(c)) {
        return false;
    }
    return cast(int, '0') <= c && c <= cast(int, '9');
}

streq: (str_a: *int, str_b: *int, len: int) -> bool = {
    i := 0;
    while (i < len) {
        if (str_a[i] != str_b[i]) {
            return false;
        }
        if (str_a[i] == 0 && str_b[i] == 0) {
            return true;
        }
        i += 1;
    }
    return true;
}

stoi: (str: *int, len: int) -> int = {
    res := 0;
    i := 0;
    while (i < len) {
        res *= 10;
        res += str[i] - cast(int, '0');
        i += 1;
    }
    return res;
}

// ==================== UTILITY ====================
read_content: () -> void = {
    buf = alloc(int, 16777216);
    nbuf = 0;
    while (true) {
        c := cast(int, readchar());
        if (c == EOF) {
            break;
        }
        buf[nbuf] = c;
        nbuf += 1;
    }
};

STRING_PRINTLN: *int;

ST_ID: int;
ST_LIT: int;

string_table: **int;
string_table_len: *int;
string_table_type: *int;
string_table_sz: int;
string_table_cap: int;

string_table_init: () -> void = {
    ST_ID = 0;
    ST_LIT = 1;

    // bruhest moment
    {
        STRING_PRINTLN    = alloc(int, 8);
        STRING_PRINTLN[0] = cast(int, 'p');
        STRING_PRINTLN[1] = cast(int, 'r');
        STRING_PRINTLN[2] = cast(int, 'i');
        STRING_PRINTLN[3] = cast(int, 'n');
        STRING_PRINTLN[4] = cast(int, 't');
        STRING_PRINTLN[5] = cast(int, 'l');
        STRING_PRINTLN[6] = cast(int, 'n');
        STRING_PRINTLN[7] = 0;
    }
}

string_table_add: (str_buf: *int, len: int) -> int = {
    if (string_table_sz == string_table_cap) {
        new_cap := string_table_cap * 2;
        if (new_cap == 0) {
            new_cap = 1;
        }

        new_table := alloc(*int, new_cap);
        new_table_len := alloc(int, new_cap);
        new_table_type := alloc(int, new_cap);
        i := 0;
        while (i < string_table_cap) {
            new_table[i] = string_table[i];
            new_table_len[i] = string_table_len[i];
            new_table_type[i] = string_table_type[i];
            i += 1;
        }

        if (string_table_cap > 0) {
            delete(string_table);
            delete(string_table_len);
            delete(string_table_type);
        }

        string_table = new_table;
        string_table_len = new_table_len;
        string_table_type = new_table_type;
        string_table_cap = new_cap;
    }
    stridx := string_table_sz;
    string_table_sz += 1;

    string_table[stridx]     = alloc(int, len);
    string_table_len[stridx] = len;

    dst := string_table[stridx];

    i := 0;
    while (i < len) {
        dst[i] = str_buf[i];
        i += 1;
    }

    return stridx;
}

string_table_print: (stridx: int) -> void = {
    len := string_table_len[stridx];
    str := string_table[stridx];
    i := 0;
    while (i < len) {
        print(cast(char, str[i]));
        i += 1;
    }
}

// ==================== LEX ====================
lex_ptr: int;
cur_tok: int;
cur_tok_beg: int;
cur_tok_end: int;

TOK_EOF    : int;
TOK_ID     : int;
TOK_STR    : int;
TOK_ARROW  : int;
TOK_INT    : int;
TOK_IF     : int;
TOK_ELSE   : int;
TOK_RETURN : int;

operator_prec: *int;
TOK_LEQ: int;
TOK_GEQ: int;
TOK_EQ : int;
TOK_NEQ: int;


lex_init: () -> void = {
    lex_ptr = 0;
    cur_tok_beg = -1;

    TOK_EOF    = 255;
    TOK_ID     = 256;
    TOK_STR    = 257;
    TOK_ARROW  = 258;
    TOK_INT    = 259;
    TOK_IF     = 260;
    TOK_ELSE   = 261;
    TOK_RETURN = 262;
    TOK_LEQ    = 263;
    TOK_GEQ    = 264;
    TOK_EQ     = 265;
    TOK_NEQ    = 266;

    operator_prec = alloc(int, 512);
    // 10 * (17 - original C implementation precedence)
    operator_prec[cast(int, '+')] = 110;
    operator_prec[cast(int, '-')] = 110;
    operator_prec[cast(int, '*')] = 120;
    operator_prec[cast(int, '/')] = 120;
    operator_prec[cast(int, '%')] = 120;
    operator_prec[cast(int, '<')] = 80;
    operator_prec[cast(int, '>')] = 80;
    operator_prec[TOK_LEQ]        = 80;
    operator_prec[TOK_GEQ]        = 80;
    operator_prec[TOK_EQ]         = 70;
    operator_prec[TOK_NEQ]        = 70;
}


lex_skip_ws: () -> void = {
    while (lex_ptr < nbuf && isspace(buf[lex_ptr])) {
        lex_ptr += 1;
    }
}

lex_skip_comments: () -> void = {
    if (buf[lex_ptr] != cast(int, '/')) {
        return;
    }
    if (lex_ptr + 1 < nbuf && buf[lex_ptr+1] == cast(int, '/')) {
        while (lex_ptr < nbuf && buf[lex_ptr] != 10) {
            lex_ptr += 1;
        }
    } else {
        return;
    }
    // TODO: multiline comments
    lex_skip_ws();
    lex_skip_comments();
}

lex_matches_arrow: () -> bool = {
    if (lex_ptr + 1 >= nbuf) {
        return false;
    }

    return cast(char, buf[lex_ptr]) == '-' && cast(char, buf[lex_ptr + 1]) == '>';
}

lex_isidchar: (c: int) -> bool = {
    // [_0-9A-Za-z]
    return isalpha(c) || isdigit(c) || (c == cast(int, '_'));
}

lex_matches_id: () -> int = {
    if (!isalpha(buf[lex_ptr])) {
        return 0;
    }
    ptr := lex_ptr;

    while (ptr < nbuf && lex_isidchar(buf[ptr])) {
        ptr += 1;
    }

    return ptr - lex_ptr;
}

lex_matches_str: () -> int = {
    if (cast(char, buf[lex_ptr]) != '"') {
        return 0;
    }
    ptr := lex_ptr + 1;
    while (ptr < nbuf && cast(char, buf[ptr]) != '"') {
        // 92: '\'  Char literals not stable.
        if (buf[ptr] == 92) {
            ptr += 2;
        } else {
            ptr += 1;
        }
    }
    if (ptr >= nbuf) {
        println("Unexpected EOF when parsing string literal!");
        // TODO: exit
        x := 1 / 0;
        return 0;
    }
    ptr += 1;
    return ptr - lex_ptr;
}

lex_matches_int: () -> int = {
    if (!isdigit(buf[lex_ptr])) {
        return 0;
    }
    ptr := lex_ptr;
    while (ptr < nbuf && isdigit(buf[ptr])) {
        ptr += 1;
    }

    if (ptr < nbuf && buf[ptr] == cast(int, '.')) {
        return 0;
    }

    return ptr - lex_ptr;
}

lex_matches_if: () -> int = {
    ptr := lex_ptr;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'i')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'f')) {
        return 0;
    }
    ptr += 1;
    if (ptr < nbuf && lex_isidchar(buf[ptr])) {
        return 0;
    }
    return 2;
}

lex_matches_else: () -> int = {
    ptr := lex_ptr;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'e')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'l')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 's')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'e')) {
        return 0;
    }
    ptr += 1;
    if (ptr < nbuf && lex_isidchar(buf[ptr])) {
        return 0;
    }
    return 4;
}

lex_matches_return: () -> int = {
    ptr := lex_ptr;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'r')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'e')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 't')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'u')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'r')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, 'n')) {
        return 0;
    }
    ptr += 1;
    if (ptr < nbuf && lex_isidchar(buf[ptr])) {
        return 0;
    }
    return 6;
}

lex_matches_leq: () -> int = {
    ptr := lex_ptr;
    if (ptr >= nbuf || buf[ptr] != cast(int, '<')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, '=')) {
        return 0;
    }
    return 2;
}

lex_matches_geq: () -> int = {
    ptr := lex_ptr;
    if (ptr >= nbuf || buf[ptr] != cast(int, '>')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, '=')) {
        return 0;
    }
    return 2;
}

lex_matches_eq: () -> int = {
    ptr := lex_ptr;
    if (ptr >= nbuf || buf[ptr] != cast(int, '=')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, '=')) {
        return 0;
    }
    return 2;
}

lex_matches_neq: () -> int = {
    ptr := lex_ptr;
    if (ptr >= nbuf || buf[ptr] != cast(int, '!')) {
        return 0;
    }
    ptr += 1;
    if (ptr >= nbuf || buf[ptr] != cast(int, '=')) {
        return 0;
    }
    return 2;
}

lex_peek: () -> int = {
    match: int;
    if (cur_tok_beg == lex_ptr) {
        return cur_tok;
    }

    lex_skip_ws();
    lex_skip_comments();

    cur_tok_beg = lex_ptr;

    if (lex_ptr >= nbuf) {
        cur_tok = TOK_EOF;
        cur_tok_end = nbuf;
        return cur_tok;
    }

    if (lex_matches_arrow()) {
        cur_tok = TOK_ARROW;
        cur_tok_end = cur_tok_beg + 2;
        return cur_tok;
    }

    match = lex_matches_if();
    if (match > 0) {
        cur_tok = TOK_IF;
        cur_tok_end = cur_tok_beg + match;
        return cur_tok;
    }

    match = lex_matches_else();
    if (match > 0) {
        cur_tok = TOK_ELSE;
        cur_tok_end = cur_tok_beg + match;
        return cur_tok;
    }

    match = lex_matches_return();
    if (match > 0) {
        cur_tok = TOK_RETURN;
        cur_tok_end = cur_tok_beg + match;
        return cur_tok;
    }

    match = lex_matches_id();
    if (match > 0) {
        cur_tok = TOK_ID;
        cur_tok_end = cur_tok_beg + match;
        return cur_tok;
    }

    match = lex_matches_str();
    if (match > 0) {
        cur_tok = TOK_STR;
        cur_tok_end = cur_tok_beg + match;
        return cur_tok;
    }

    match = lex_matches_int();
    if (match > 0) {
        cur_tok = TOK_INT;
        cur_tok_end = cur_tok_beg + match;
        return cur_tok;
    }

    match = lex_matches_leq();
    if (match > 0) {
        cur_tok = TOK_LEQ;
        cur_tok_end = cur_tok_beg + 2;
        return cur_tok;
    }

    match = lex_matches_geq();
    if (match > 0) {
        cur_tok = TOK_GEQ;
        cur_tok_end = cur_tok_beg + 2;
        return cur_tok;
    }

    match = lex_matches_eq();
    if (match > 0) {
        cur_tok = TOK_EQ;
        cur_tok_end = cur_tok_beg + 2;
        return cur_tok;
    }

    match = lex_matches_neq();
    if (match > 0) {
        cur_tok = TOK_NEQ;
        cur_tok_end = cur_tok_beg + 2;
        return cur_tok;
    }

    cur_tok = buf[lex_ptr];
    cur_tok_end = cur_tok_beg + 1;
    return cur_tok;
}

lex_advance: () -> void = {
    lex_peek();
    lex_ptr = cur_tok_end;
}

tok_print: (t: int) -> void = {
    if (isascii(t)) {
        println(cast(char, t));
        return;
    }
    if (t == TOK_EOF) {
        println("<EOF>");
        return;
    }
    if (t == TOK_ID) {
        println("<identifier>");
        return;
    }
    if (t == TOK_STR) {
        println("<string>");
        return;
    }
    if (t == TOK_ARROW) {
        println("->");
        return;
    }
    if (t == TOK_INT) {
        println("<integer>");
        return;
    }
    if (t == TOK_IF) {
        println("if");
        return;
    }
    if (t == TOK_ELSE) {
        println("else");
        return;
    }
    if (t == TOK_RETURN) {
        println("return");
        return;
    }
    if (t == TOK_LEQ) {
        println("<=");
        return;
    }
    if (t == TOK_GEQ) {
        println(">=");
        return;
    }
    if (t == TOK_EQ) {
        println("==");
        return;
    }
    if (t == TOK_NEQ) {
        println("!=");
        return;
    }

    println("???");
}

peek_expect_advance: (expected: int) -> int = {
    token := lex_peek();
    if (token != expected) {
        print("Unexpected token: ");
        tok_print(token);
        print("Expected: ");
        tok_print(expected);
        exit := 1 / 0;
    }
    lex_advance();
    return token;
}

// ==================== PARSE ====================

// Node types
NODE_LIST   : int; // [any, ...]
NODE_ID     : int; // leaf
NODE_DECL   : int; // [identifier, type] | [identifier, type?, expr]
NODE_TYPE   : int; // [identifier] | [list[declaration], type] (func)
NODE_BLOCK  : int; // list
NODE_CALL   : int; // [identifier, list[expression]]
NODE_LIT_STR: int; // leaf
NODE_LIT_INT: int; // leaf
NODE_BINOP  : int; // [expression, expression]
NODE_IF     : int; // [expr, expr] | [expr, expr, expr]
NODE_RETURN : int; // [] | [expr]

node_da_cap: int;
node_da_sz: int;
node_type: *int;
// array of children lists
node_children: **int;
// array of children list capacities
node_children_cap: *int;
// array of children list sizes
node_children_sz : *int;
// optional string data: index in string table
node_data_str : *int;
// optional integer literal
node_data_int : *int;
// optional operator
node_data_op  : *int;
// optional symbol id
node_data_sym : *int;
// optional scope id for blocks
node_data_block_scope: *int;

node_create: (ntype: int) -> int = {
    if (node_da_sz == node_da_cap) {
        new_cap := node_da_cap * 2;
        if (new_cap == 0) {
            new_cap = 1;
        }
        new_type := alloc(int, new_cap);
        new_children := alloc(*int, new_cap);
        new_children_cap := alloc(int, new_cap);
        new_children_sz := alloc(int, new_cap);
        new_data_str := alloc(int, new_cap);
        new_data_int := alloc(int, new_cap);
        new_data_op := alloc(int, new_cap);
        new_data_sym := alloc(int, new_cap);
        new_data_block_scope := alloc(int, new_cap);

        // copy data to new buffers
        i := 0;
        while (i < node_da_cap) {
            new_type[i] = node_type[i];
            new_children[i] = node_children[i];
            new_children_cap[i] = node_children_cap[i];
            new_children_sz[i] = node_children_sz[i];
            new_data_str[i] = node_data_str[i];
            new_data_int[i] = node_data_int[i];
            new_data_op[i] = node_data_op[i];
            new_data_sym[i] = node_data_sym[i];
            new_data_block_scope[i] = node_data_block_scope[i];
            i += 1;
        }

        // free old
        if (node_da_cap != 0) {
            delete(node_type);
            delete(node_children);
            delete(node_children_cap);
            delete(node_children_sz);
            delete(node_data_str);
            delete(node_data_int);
            delete(node_data_op);
            delete(node_data_sym);
            delete(node_data_block_scope);
        }

        // update
        node_type = new_type;
        node_children = new_children;
        node_children_cap = new_children_cap;
        node_children_sz = new_children_sz;
        node_data_str = new_data_str;
        node_data_int = new_data_int;
        node_data_op = new_data_op;
        node_data_sym = new_data_sym;
        node_data_block_scope = new_data_block_scope;

        node_da_cap = new_cap;
    }


    // assert node_da_sz < node_da_cap
    ret := node_da_sz;

    node_type[ret] = ntype;
    node_children_cap[ret] = 0;
    node_children_sz[ret] = 0;
    node_data_sym[ret] = 0;

    node_da_sz += 1;
    return ret;
}

node_add_child: (parent: int, child: int) -> void = {
    cap := node_children_cap[parent];
    sz  := node_children_sz[parent];

    if (sz == cap) {
        new_cap := cap * 2;

        if (new_cap == 0) {
            new_cap = 1;
        }

        new_children := alloc(int, new_cap);
        old_children := node_children[parent];

        i := 0;
        while (i < cap) {
            new_children[i] = old_children[i];
            i += 1;
        }

        if (cap != 0) {
            delete(old_children);
        }

        node_children[parent] = new_children;
        node_children_cap[parent] = new_cap;
    }

    dst := node_children[parent];
    dst[sz] = child;

    node_children_sz[parent] += 1;
}

node_set_idstr: (node: int) -> void = {
    strlen := cur_tok_end - cur_tok_beg;
    ptr := buf + cur_tok_beg;
    stridx := string_table_add(ptr, strlen);
    node_data_str[node] = stridx;
    string_table_type[stridx] = ST_ID;
}

node_set_strdata: (node: int) -> void = {
    strlen := cur_tok_end - cur_tok_beg - 2;
    ptr := buf + (cur_tok_beg + 1);
    stridx := string_table_add(ptr, strlen);
    node_data_str[node] = stridx;
    string_table_type[stridx] = ST_LIT;
}

node_set_intdata: (node: int) -> void = {
    strlen := cur_tok_end - cur_tok_beg;
    ptr := buf + cur_tok_beg;
    node_data_int[node] = stoi(ptr, strlen);
}

decl_get_type: (decl_node: int) -> int = {
    children := node_children[decl_node];
    if (node_type[children[1]] == NODE_TYPE) {
        return children[1];
    }
    return -1;
}

decl_get_body: (decl_node: int) -> int = {
    children := node_children[decl_node];
    if (node_children_sz[decl_node] == 3) {
        return children[2];
    }
    if (node_type[children[1]] != NODE_TYPE) {
        return children[1];
    }
    return -1;
}

parser_init: () -> void = {
    NODE_LIST    = 0;
    NODE_ID      = 1;
    NODE_DECL    = 2;
    NODE_TYPE    = 3;
    NODE_BLOCK   = 4;
    NODE_CALL    = 5;
    NODE_LIT_STR = 6;
    NODE_LIT_INT = 7;
    NODE_BINOP   = 8;
    NODE_IF      = 9;
    NODE_RETURN  = 10;

}

parse_type: () -> int = {
    type_node := node_create(NODE_TYPE);

    token := lex_peek();
    if (token == cast(int, '(')) {
        // function type
        lex_advance();

        // TODO: argument list
        decl_list_node := node_create(NODE_LIST);

        token = lex_peek();
        while (token == TOK_ID) {
            id_node := node_create(NODE_ID);
            node_set_idstr(id_node);

            lex_advance();

            decl_node := parse_declaration(id_node);
            node_add_child(decl_list_node, decl_node);

            token = lex_peek();

            if (token == cast(int, ',')) {
                lex_advance();
                token = lex_peek();
                continue;
            }
        }

        node_add_child(type_node, decl_list_node);

        peek_expect_advance(cast(int, ')'));
        peek_expect_advance(TOK_ARROW);

        return_type_node := parse_type();

        node_add_child(type_node, return_type_node);

        return type_node;
    }

    if (token != TOK_ID) {
        print("Unexpected token: ");
        tok_print(token);
        exit := 1 / 0;
    }

    {
        id_node := node_create(NODE_ID);
        node_set_idstr(id_node);
        node_add_child(type_node, id_node);
    }
    lex_advance();

    return type_node;
}

parse_declaration: (id_node: int) -> int = {
    decl_node := node_create(NODE_DECL);

    node_add_child(decl_node, id_node);

    peek_expect_advance(cast(int, ':'));

    token := lex_peek();

    if (token == cast(int, '=')) {
        println("Not implemented :=");
        exit := 1 / 0;
    }

    // type
    {
        type_node := parse_type();
        node_add_child(decl_node, type_node);
    }

    token = lex_peek();

    // these are in our FOLLOW set
    if (token == cast(int, ';') || token == cast(int, ')') || token == cast(int, ',')) {
        return decl_node;
    }

    peek_expect_advance(cast(int, '='));

    token = lex_peek();

    node_add_child(decl_node, parse_expression());

    return decl_node;
}

parse_block: () -> int = {
    block_node := node_create(NODE_BLOCK);

    while (true) {
        token := lex_peek();
        if (token == cast(int, '}')) {
            break;
        }

        if (token == cast(int, ';')) {
            lex_advance();
            continue;
        }

        expect_semicolon := !(
             (token == TOK_IF)
          || (token == cast(int, '{'))
        );

        node_add_child(block_node, parse_expression());

        if (expect_semicolon) {
            peek_expect_advance(cast(int, ';'));
        }

        //print("Unexpected token: ");
        //tok_print(token);
        //exit := 1 / 0;
    }

    return block_node;
}

get_tok_precedence: (tok: int) -> int = {
    prec := operator_prec[tok];
    if (prec == 0) {
        // not registered
        return -1;
    }
    return prec;
}

// identifierexpr
//     ::= identifier (TODO)
//     ::= identifier ([ expression [ , expression ]*  ])
//     ::= identifier : [type] [= expression]
parse_identifier_expr: () -> int = {
    token := lex_peek();

    id_node := node_create(NODE_ID);
    node_set_idstr(id_node);

    lex_advance();

    token = lex_peek();

    if (token == cast(int, '(')) {
        return parse_function_call(id_node);
    }
    if (token == cast(int, ':')) {
        return parse_declaration(id_node);
    }
    return id_node;
}

parse_function_call: (id_node: int) -> int = {
    call_node := node_create(NODE_CALL);
    node_add_child(call_node, id_node);

    list_node := node_create(NODE_LIST);
    peek_expect_advance(cast(int, '('));

    token := lex_peek();
    while (token != cast(int, ')')) {
        node_add_child(list_node, parse_expression());

        token = lex_peek();
        if (token == cast(int, ')')) {
            break;
        }
        token = peek_expect_advance(cast(int, ','));
    }
    lex_advance();

    node_add_child(call_node, list_node);

    return call_node;
}

// parenexpr
//     ::= ( expr )
parse_paren_expr: () -> int = {
    peek_expect_advance(cast(int, '('));
    expr := parse_expression();
    peek_expect_advance(cast(int, ')'));
    return expr;
}

parse_if_expr: () -> int = {
    peek_expect_advance(TOK_IF);
    cond := parse_paren_expr();
    body := parse_expression();
    token := lex_peek();

    if_node := node_create(NODE_IF);
    node_add_child(if_node, cond);
    node_add_child(if_node, body);

    if (token == TOK_ELSE) {
        lex_advance();
        else_body := parse_expression();
        node_add_child(if_node, else_body);
    }
    return if_node;
}

parse_return_expr: () -> int = {
    peek_expect_advance(TOK_RETURN);
    token := lex_peek();

    ret_node := node_create(NODE_RETURN);

    if (token == cast(int, ';')) {
        return ret_node;
    }
    node_add_child(ret_node, parse_expression());
    return ret_node;
}

// primaryexpr
//     ::= identifierexpr
//     ::= lit_int
//     ::= lit_str
//     ::= parenexpr
//     ::= block
//     ::= ifexpr
//     ::= returnexpr
parse_primary_expr: () -> int = {
    token := lex_peek();

    if (token == TOK_STR) {
        str_node := node_create(NODE_LIT_STR);
        node_set_strdata(str_node);
        lex_advance();
        return str_node;
    }

    if (token == TOK_INT) {
        int_node := node_create(NODE_LIT_INT);
        node_set_intdata(int_node);
        lex_advance();
        return int_node;
    }

    if (token == cast(int, '(')) {
        return parse_paren_expr();
    }

    if (token == TOK_ID) {
        return parse_identifier_expr();
    }
    if (token == cast(int, '{')) {
        lex_advance();
        block_node := parse_block();
        peek_expect_advance(cast(int, '}'));
        return block_node;
    }

    if (token == TOK_IF) {
        return parse_if_expr();
    }

    if (token == TOK_RETURN) {
        return parse_return_expr();
    }


    print("parse_primary_expr unhandled token: ");
    tok_print(token);
    return 0;
}

parse_expr_rhs: (expr_prec: int, lhs: int) -> int = {
    while (true) {
        token := lex_peek();
        prec := get_tok_precedence(token);
        if (prec < expr_prec) {
            return lhs;
        }
        // token is guaranteed to be an operator
        lex_advance();
        rhs := parse_primary_expr();

        next_prec := get_tok_precedence(lex_peek());
        if (prec < next_prec) {
            rhs = parse_expr_rhs(prec + 1, rhs);
        }

        // merge
        op_node := node_create(NODE_BINOP);
        node_data_op[op_node] = token;
        node_add_child(op_node, lhs);
        node_add_child(op_node, rhs);

        lhs = op_node;
    }
    return lhs;
}

// expression
//     ::= primary [binop, primary]*
parse_expression: () -> int = {
    lhs := parse_primary_expr();
    return parse_expr_rhs(0, lhs);
}

parse: () -> int = {
    root := node_create(NODE_LIST);

    while (true) {
        tok := lex_peek();

        if (tok == TOK_EOF) {
            break;
        }
        if (tok == cast(int, ';')) {
            lex_advance();
            continue;
        }
        if (tok == TOK_ID) {
            // eat identifier
            id_node := node_create(NODE_ID);

            // collect str
            node_set_idstr(id_node);

            lex_advance();

            node := parse_declaration(id_node);

            node_add_child(root, node);
            continue;
        }

        print("Unexpected token: ");
        tok_print(tok);
        //exit := 1 / 0;
        lex_advance();
    }

    return root;
}

// ==================== SYMBOL ====================
SYMBOL_INT: int;
SYMBOL_FUNC: int;


// first index: by scope. 
// array at location: list of indices in string table
scope_parent: *int; // scope_parent[s] = parent scope of s

scope_syms: **int;
scope_szs: *int;
scope_caps: *int;

scope_sz: int;
scope_cap: int;

// given the symbol, get its name (index in string table)
symbol_table_str: *int;
symbol_table_type: *int;
symbol_table_scope: *int;
symbol_table_decl_node: *int;
// sequence number in function
symbol_table_seq: *int;
symbol_table_sz: int;
symbol_table_cap: int;

symbol_table_seq_counter: int;

symbol_table_init: () -> void = {
    SYMBOL_INT = 0;
    SYMBOL_FUNC = 1;

    scope_parent = alloc(int, 1);
    scope_syms = alloc(*int, 1);
    scope_szs = alloc(int, 1);
    scope_caps = alloc(int, 1);
    scope_sz = 1;
    scope_cap = 1;

    scope_szs[0] = 0;
    scope_caps[0] = 0;
}

decl_get_symbol_type: (node: int) -> int = {
    // TODO: use type info
    if (node_children_sz[node] <= 2) {
        return SYMBOL_INT;
    }
    children := node_children[node];
    if (node_type[children[2]] == NODE_BLOCK) {
        return SYMBOL_FUNC;
    }
    return SYMBOL_INT;
}

scope_is_parent: (par: int, scope: int) -> bool = {
    while (scope >= par && scope > 0) {
        if (scope == par) {
            return true;
        }

        scope = scope_parent[scope];
    }
    return false;
}

// lookup a name from a scope
// return symbol id or -1 if not found
symbol_table_lookup: (stridx: int, scope: int) -> int = {
    len := string_table_len[stridx];
    while (true) {
        syms := scope_syms[scope];

        i := 0;

        while (i < scope_szs[scope]) {
            sym := syms[i];

            intable_stridx := symbol_table_str[sym];
            intable_len := string_table_len[intable_stridx];
            if (len == intable_len) {
                if (streq(string_table[stridx], string_table[intable_stridx], len)) {
                    return sym;
                }
            }

            i += 1;
        }

        if (scope == 0) {
            break;
        }
        scope = scope_parent[scope];
    }

    return -1;
}

// append a symbol to the symbol list of a scope
symbol_table_scope_append: (scope: int, symidx: int) -> void = {
    sz := scope_szs[scope];
    cap := scope_caps[scope];

    if (sz == cap) {
        new_cap := cap * 2;
        if (new_cap == 0) {
            new_cap = 1;
        }

        new_data_syms := alloc(int, new_cap);
        old_data_syms := scope_syms[scope];

        i := 0;

        while (i < cap) {
            new_data_syms[i] = old_data_syms[i];
            i += 1;
        }

        if (cap > 0) {
            delete(old_data_syms);
        }

        scope_syms[scope] = new_data_syms;
        scope_caps[scope] = new_cap;
    }
    arr := scope_syms[scope];
    arr[sz] = symidx;
    scope_szs[scope] = sz + 1;
}

// assumes the scope exists
symbol_table_insert: (decl_node: int, stridx: int, scope: int, symtype: int) -> int = {
    if (symbol_table_sz == symbol_table_cap) {
        new_cap := symbol_table_cap * 2;
        if (new_cap == 0) {
            new_cap = 1;
        }

        new_table_str       := alloc(int, new_cap);
        new_table_type      := alloc(int, new_cap);
        new_table_scope     := alloc(int, new_cap);
        new_table_seq       := alloc(int, new_cap);
        new_table_decl_node := alloc(int, new_cap);

        i := 0;
        while (i < symbol_table_cap) {
            new_table_str[i]       = symbol_table_str[i];
            new_table_type[i]      = symbol_table_type[i];
            new_table_scope[i]     = symbol_table_scope[i];
            new_table_seq[i]       = symbol_table_seq[i];
            new_table_decl_node[i] = symbol_table_decl_node[i];
            i += 1;
        }

        if (symbol_table_cap > 0) {
            delete(symbol_table_str);
            delete(symbol_table_type);
            delete(symbol_table_scope);
            delete(symbol_table_seq);
            delete(symbol_table_decl_node);
        }

        symbol_table_str       = new_table_str;
        symbol_table_type      = new_table_type;
        symbol_table_scope     = new_table_scope;
        symbol_table_seq       = new_table_seq;
        symbol_table_decl_node = new_table_decl_node;
        symbol_table_cap       = new_cap;
    }

    symidx := symbol_table_sz;
    symbol_table_sz += 1;

    symbol_table_str[symidx]       = stridx;
    symbol_table_type[symidx]      = symtype;
    symbol_table_scope[symidx]     = scope;
    symbol_table_decl_node[symidx] = decl_node;

    symbol_table_scope_append(scope, symidx);

    return symidx;
}

// Create a new scope with the given parent
symbol_table_scope_add: (par: int) -> int = {
    if (scope_sz == scope_cap) {
        new_cap := scope_cap * 2;
        if (new_cap == 0) {
            new_cap = 1;
        }

        new_data_parent := alloc(int, new_cap);
        new_data_syms := alloc(*int, new_cap);
        new_data_szs := alloc(int, new_cap);
        new_data_caps := alloc(int, new_cap);

        i := 0;

        while (i < scope_cap) {
            new_data_parent[i] = scope_parent[i];
            new_data_syms[i] = scope_syms[i];
            new_data_szs[i] = scope_szs[i];
            new_data_caps[i] = scope_caps[i];
            i += 1;
        }

        if (scope_cap > 0) {
            delete(scope_parent);
            delete(scope_syms);
            delete(scope_szs);
            delete(scope_caps);
        }

        scope_parent = new_data_parent;
        scope_syms = new_data_syms;
        scope_szs = new_data_szs;
        scope_caps = new_data_caps;
        scope_cap = new_cap;
    }

    scope := scope_sz;
    scope_sz += 1;

    scope_parent[scope] = par;
    scope_szs[scope] = 0;
    scope_caps[scope] = 0;
    return scope;
}

resolve_symbols: (root: int) -> void = {
    // builtin functions
    {
        println_idx := string_table_add(STRING_PRINTLN, 7);
        symbol_table_insert(-1, println_idx, 0, SYMBOL_FUNC);
    }


    // register top level

    i := 0;
    children := node_children[root];

    while (i < node_children_sz[root]) {
        child := children[i];
        if (node_type[child] != NODE_DECL) {
            print("Unhandled root node type in resolve_symbols: ");
            node_print(child);
            println();
            exit := 1 / 0;
        }

        subchildren := node_children[child];

        id_node := subchildren[0];

        id_str := node_data_str[id_node];
        decl_type := decl_get_symbol_type(child);
        idx := symbol_table_insert(child, id_str, 0, decl_type);
        node_data_sym[id_node] = idx;

        i += 1;
    }

    // register all blocks
    i = 0;

    while (i < node_children_sz[root]) {
        child := children[i];
        body := decl_get_body(child);
        if (body >= 0) {
            symbol_table_seq_counter = 0;

            decl_type := decl_get_symbol_type(child);
            type_node := decl_get_type(child);

            if (decl_type == SYMBOL_FUNC) {
                func_scope := symbol_table_scope_add(0);
                type_children := node_children[type_node];
                node_data_block_scope[child] = func_scope;
                // arg declarations
                resolve_node(type_children[0], func_scope);
                resolve_node(body, func_scope);
            } else {
                resolve_node(body, 0);
            }
        }
        i += 1;
    }
}

resolve_node: (node: int, scope: int) -> void = {
    children := node_children[node];
    if (node_type[node] == NODE_DECL) {
        // references in body first
        body := decl_get_body(node);
        if (body >= 0) {
            resolve_node(body, scope);
        }
        // register new symbol
        id_node := children[0];
        id_str := node_data_str[id_node];

        exists := symbol_table_lookup(id_str, scope);
        if (exists >= 0 && symbol_table_scope[exists] == scope) {
            print("Error: redeclaration of ");
            string_table_print(id_str);
            println();
            exit := 1 / 0;
        }

        idx := symbol_table_insert(node, id_str, scope, decl_get_symbol_type(node));

        symbol_table_seq[idx] = symbol_table_seq_counter;
        symbol_table_seq_counter += 1;

        node_data_sym[id_node] = idx;
        return;
    }

    new_scope := scope;
    if (node_type[node] == NODE_BLOCK) {
        new_scope = symbol_table_scope_add(scope);
        node_data_block_scope[node] = new_scope;
    }

    if ( (node_type[node] == NODE_IF)
      || (node_type[node] == NODE_BLOCK)
      || (node_type[node] == NODE_CALL)
      || (node_type[node] == NODE_LIT_INT)
      || (node_type[node] == NODE_LIT_STR)
      || (node_type[node] == NODE_LIST)
      || (node_type[node] == NODE_BINOP)
      || (node_type[node] == NODE_RETURN)
    ) {

        i := 0;
        while (i < node_children_sz[node]) {
            resolve_node(children[i], new_scope);
            i += 1;
        }
        return;
    }
    if (node_type[node] == NODE_ID) {
        id_str := node_data_str[node];
        idx := symbol_table_lookup(
            id_str,
            scope
        );

        if (idx < 0) {
            print("Unresolved reference: ");
            string_table_print(id_str);
            println();
            exit := 1 / 0;
        }
        node_data_sym[node] = idx;
        return;
    }

    print("resolve_node unhandled: ");
    node_print(node);
    println();
    exit := 1/ 0;
}

// ==================== GEN ====================
LABEL_COUNTER: int;

curr_func_gen_sym: int;

generate_code: (root: int) -> void = {

    { // string data. Consts?
        println(".section .rodata");
        println("strout: .asciz \"%s\"");
        println("intout: .asciz \"%ld\"");

        i := 0;
        while (i < string_table_sz) {
            if (string_table_type[i] != ST_LIT) {
                i += 1;
                continue;
            }
            print("string");
            print(i);
            print(":  .asciz \"");

            j := 0;

            str := string_table[i];
            while (j < string_table_len[i]) {
                print(cast(char, str[j]));
                j += 1;
            }
            println("\"");

            i += 1;
        }
    }

    { // global vars
        println(".section .bss");
        println(".align 8");

        i := 0;

        global_syms := scope_syms[0];
        while (i < scope_szs[0]) {
            sym := global_syms[i];

            if (symbol_table_type[sym] == SYMBOL_FUNC) {
                i += 1;
                continue;
            }

            if (symbol_table_type[sym] == SYMBOL_INT) {
                print(".");
                string_table_print(symbol_table_str[sym]);
                println(": .zero 8");
                i += 1;
                continue;
            }

            println("Unhandled global symbol type:", symbol_table_type[sym]);
            exit := 1 / 0;
        }
    }

    println(".text");

    i := 0;

    root_children := node_children[root];
    while (i < node_children_sz[root]) {
        child := root_children[i];
        child_children := node_children[child];

        if (node_type[child] == NODE_DECL) {
            id_node := child_children[0];
            sym := node_data_sym[id_node];

            if (symbol_table_type[sym] == SYMBOL_FUNC) {
                curr_func_gen_sym = sym;
                generate_function_code(
                    node_data_block_scope[child],
                    child_children[0],
                    child_children[1],
                    child_children[2]
                );
            }
        } else {
            println("Not implemented: root decl node type");
            exit := 1 / 0;
        }

        i += 1;
    }

    // entrypoint
    println("main:");
    println("    pushq %rbp");
    println("    movq %rsp, %rbp");
    println("    andq $-16, %rsp");
    println("    call .main");
	println("    movq %rbp, %rsp");
	println("    popq %rbp");
	println("    movq $0, %rdi");
	println("    pushq %rbp");
	println("    movq %rsp, %rbp");
	println("    andq $-16, %rsp");
	println("    call exit");
    println(".global main");
}

emit_arg_reg: (arg_idx: int) -> void = {
    if (arg_idx == 0) {
        print("%rdi");
        return;
    }
    if (arg_idx == 1) {
        print("%rsi");
        return;
    }
    if (arg_idx == 2) {
        print("%rdx");
        return;
    }
    if (arg_idx == 3) {
        print("%rcx");
        return;
    }
    if (arg_idx == 4) {
        print("%r8");
        return;
    }
    if (arg_idx == 5) {
        print("%r9");
        return;
    }

    // TODO: read from stack
    println("Too many arguments!");
    exit := 1 / 0;
}

generate_function_code: (func_scope: int, id_node: int, type_node: int, body_node: int) -> void = {
    print(".");
    string_table_print(node_data_str[id_node]);
    println(":");

    println("    pushq %rbp");
    println("    movq %rsp, %rbp");

    local_space := 0;
    {
        // make some stack space
        sym := 0;
        if (func_scope == 0) {
            println("Something went wrong");
            exit := 1 / 0;
        }


        while (sym < symbol_table_sz) {
            sc := symbol_table_scope[sym];
            if (scope_is_parent(func_scope, sc)) {
                local_space += 8; // TODO: type sizeof
            }
            sym += 1;
        }

        // align
        local_space = ((local_space + 15) / 16) *16;

        print("    subq $");
        print(local_space);
        println(", %rsp");
    }

    {
        // args
        type_children := node_children[type_node];
        args_list := node_children[type_children[0]];
        i := 0;
        while (i < node_children_sz[type_children[0]]) {
            decl := args_list[i];
            decl_children := node_children[decl];
            id_node := decl_children[0];
            sym := node_data_sym[id_node];
            print("    movq ");

            emit_arg_reg(i);
            print(", ");
            emit_sym_access(sym);
            println();

            i += 1;
        }
    }

    body_children := node_children[body_node];

    i := 0;
    while (i < node_children_sz[body_node]) {
        generate_node(body_children[i]);
        i += 1;
    }

    print(".");
    string_table_print(node_data_str[id_node]);
    println(".epilogue:");
    println("    movq %rbp, %rsp");
    println("    popq %rbp");
    println("    ret");
}

generate_node: (node: int) -> void = {
    if (node_type[node] == NODE_CALL) {
        generate_function_call(node);
        return;
    }

    if (node_type[node] == NODE_IF) {
        generate_if(node);
        return;
    }

    if (node_type[node] == NODE_DECL) {
        generate_decl(node);
        return;
    }

    if (node_type[node] == NODE_BLOCK) {
        children := node_children[node];
        i := 0;
        while (i < node_children_sz[node]) {
            generate_node(children[i]);
            i += 1;
        }
        return;
    }

    if (node_type[node] == NODE_RETURN) {
        generate_return(node);
        return;
    }

    print("Unhandled node type in generate_node: ");
    node_print(node);
    println();
    exit := 1 / 0;
}

generate_function_call: (node: int) -> void = {
    children := node_children[node];
    id_node := children[0];

    id_stridx := node_data_str[id_node];

    if (streq(
        string_table[id_stridx], 
        STRING_PRINTLN, 
        string_table_len[id_stridx])
    ) {
        generate_call_println(children[1]);
        return;
    }

    call_arg_list_node := children[1];
    call_args := node_children[call_arg_list_node];

    i := 0;

    while (i < node_children_sz[call_arg_list_node]) {
        // TODO: caller saved eeee
        generate_expression(call_args[i]);
        print("    movq %rax, ");
        emit_arg_reg(i);
        println();
        i += 1;
    }

    println("    pushq %rcx");
    print("    call .");
    string_table_print(id_stridx);
    println();
    println("    popq %rcx");
}

generate_call_println: (args_node: int) -> void = {
    args := node_children[args_node];

    i := 0;
    while (i < node_children_sz[args_node]) {
        if (i > 0) {
            println("    movq $' ', %rdi");
            println("    call putchar");
        }

        arg := args[i];

        generate_expression(arg);
        println("    movq %rax, %rsi");

        while (true) {
            // TODO: type checking and not this mess
            if (node_type[arg] == NODE_LIT_STR) {
                println("    leaq strout(%rip), %rdi");
                break;
            }

            if (node_type[arg] == NODE_LIT_INT 
             || node_type[arg] == NODE_BINOP
             || (node_type[arg] == NODE_ID && symbol_table_type[node_data_sym[arg]] == SYMBOL_INT)
             || node_type[arg] == NODE_CALL) {
                println("    leaq intout(%rip), %rdi");
                break;
            }

            println("Unhandled node type println");
            print("Violating: ");
            node_print(arg);
            println();
            exit := 1 / 0;
        }
        println("    movq $1, %rax");
        println("    call printf");
        i += 1;
    }

    println("    movq $'\\n', %rdi");
    println("    call putchar");
}

// expects: lhs in %rcx, rhs in %rax
// result in %rax
generate_binop: (op: int) -> void = {
    if (op == cast(int, '+')) {
        println("    addq %rcx, %rax");
        return;
    }
    if (op == cast(int, '-')) {
        println("    subq %rax, %rcx");
        println("    movq %rcx, %rax");
        return;
    }
    if (op == cast(int, '*')) {
        println("    imulq %rcx, %rax");
        return;
    }
    if (op == cast(int, '/')) {
        // swap
        println("    xchg %rax, %rcx");
        // sign extend rax
        println("    cqo");
        // div by rcx
        println("    idivq %rcx");
        return;
    }
    if (op == cast(int, '%')) {
        // swap
        println("    xchg %rax, %rcx");
        // sign extend rax
        println("    cqo");
        // div by rcx
        println("    idivq %rcx");
        // get remainder
        println("    movq %rdx, %rax");
        return;
    }

    if (op == cast(int, '<')) {
        println("    cmpq %rax, %rcx");
        println("    setl %al");
        println("    movzbq %al, %rax");
        return;
    }

    if (op == cast(int, '>')) {
        println("    cmpq %rax, %rcx");
        println("    setg %al");
        println("    movzbq %al, %rax");
        return;
    }

    if (op == TOK_LEQ) {
        println("    cmpq %rax, %rcx");
        println("    setle %al");
        println("    movzbq %al, %rax");
        return;
    }

    if (op == TOK_GEQ) {
        println("    cmpq %rax, %rcx");
        println("    setge %al");
        println("    movzbq %al, %rax");
        return;
    }
    if (op == TOK_EQ) {
        println("    cmpq %rax, %rcx");
        println("    sete %al");
        println("    movzbq %al, %rax");
        return;
    }
    if (op == TOK_NEQ) {
        println("    cmpq %rax, %rcx");
        println("    setne %al");
        println("    movzbq %al, %rax");
        return;
    }

    println("Unhandled binop gen");
    exit := 1 / 0;
}

// Place result of computation in rax
generate_expression: (node: int) -> void = {
    if (node_type[node] == NODE_LIT_STR) {
        print("    leaq string");
        print(node_data_str[node]);
        print("(%rip)");
        println(", %rax");
        return;
    }

    if (node_type[node] == NODE_LIT_INT) {
        print("    movq $");
        print(node_data_int[node]);
        println(", %rax");
        return;
    }

    if (node_type[node] == NODE_BINOP) {
        children := node_children[node];
        generate_expression(children[0]);
        println("    pushq %rax");
        generate_expression(children[1]);
        println("    popq %rcx");
        generate_binop(node_data_op[node]);
        return;
    }

    if (node_type[node] == NODE_CALL) {
        generate_function_call(node);
        return;
    }

    if (node_type[node] == NODE_BLOCK) {
        children := node_children[node];

        i := 0;
        while (i < node_children_sz[node]) {
            generate_expression(children[i]);
            i += 1;
        }
        return;
    }

    if (node_type[node] == NODE_IF) {
        generate_if(node);
        return;
    }

    if (node_type[node] == NODE_RETURN) {
        generate_return(node);
        return;
    }

    if (node_type[node] == NODE_ID) {
        print("    movq ");
        emit_sym_access(node_data_sym[node]);
        println(", %rax");
        return;
    }

    print("generate_expression unhandled node type: ");
    node_print(node);
    println();
    exit := 1 / 0;
}

generate_if: (node: int) -> void = {
    children := node_children[node];

    cur_if := gen_next_label();
    has_else := (node_children_sz[node] > 2);

    generate_expression(children[0]);

    println("    cmpq $0, %rax");

    if (has_else) {
        print("    je ELSE");
        println(cur_if);
    } else {
        print("    je ENDIF");
        println(cur_if);
    }

    generate_expression(children[1]);

    if (has_else) {
        print("    jmp ENDIF");
        println(cur_if);

        print("ELSE");
        print(cur_if);
        println(":");

        generate_expression(children[2]);
    }

    // generate condition
    // generate body
    // generate else body
    // generate endif
    print("ENDIF");
    print(cur_if);
    println(":");
}

generate_return: (node: int) -> void = {
    children := node_children[node];
    if (node_children_sz[node] > 0) {
        generate_expression(children[0]);
        // now it is in %rax as it should
    }
    print("    jmp .");
    string_table_print(symbol_table_str[curr_func_gen_sym]);
    println(".epilogue");
}

emit_sym_access: (sym: int) -> void = {
    if (symbol_table_scope[sym] == 0) {
        // global
        print(".");
        string_table_print(symbol_table_str[sym]);
        print("(%rip)");
        return;
    }

    seq := symbol_table_seq[sym];

    offs := - (seq + 1) * 8;

    print(offs);
    print("(%rbp)");
}

generate_decl: (node: int) -> void = {
    children := node_children[node];
    rhs: int;
    if (node_type[children[1]] == NODE_TYPE) {
        if (node_children_sz[node] == 2) {
            return;
        }
        rhs = children[2];
    } else {
        rhs = children[1];
    }

    generate_expression(rhs);

    print("    movq %rax, ");
    emit_sym_access(node_data_sym[children[0]]);
    println();
}

gen_next_label: () -> int = {
    lab := LABEL_COUNTER;
    LABEL_COUNTER += 1;
    return lab;
}

// ==================== DEBUG ====================
node_print: (node: int) -> void = {
    typ := node_type[node];
    if (typ == NODE_LIST) {
        print("LIST");
        return;
    }
    if (typ == NODE_ID) {
        print("ID (");
        string_table_print(node_data_str[node]);
        print(")");

        if (node_data_sym[node] > 0) {
            print(" -> ");
            print(node_data_sym[node]);
        }
        return;
    }
    if (typ == NODE_DECL) {
        print("DECL");
        return;
    }
    if (typ == NODE_TYPE) {
        print("TYPE");
        return;
    }
    if (typ == NODE_BLOCK) {
        print("BLOCK");
        return;
    }
    if (typ == NODE_CALL) {
        print("CALL");
        return;
    }
    if (typ == NODE_LIT_STR) {
        print("LIT_STR \"");
        string_table_print(node_data_str[node]);
        print("\"");
        return;
    }
    if (typ == NODE_LIT_INT) {
        print("LIT_INT (");
        print(node_data_int[node]);
        print(")");
        return;
    }
    if (typ == NODE_BINOP) {
        print("BINOP ");
        print(cast(char, node_data_op[node]));
        return;
    }
    if (typ == NODE_IF) {
        print("IF ");
        return;
    }
    if (typ == NODE_RETURN) {
        print("RETURN");
        return;
    }
    print("????");
}

print_tree: (node: int, indent: int) -> void = {
    {
        i := 0;
        while (i < indent) {
            print(" ");
            i += 1;
        }
    }
    node_print(node);
    println();

    i := 0;
    children := node_children[node];
    while (i < node_children_sz[node]) {
        print_tree(children[i], indent + 2);
        i += 1;
    }
}

print_symbol: (sym: int) -> void = {
    print(sym);
    print(" ");
    string_table_print(symbol_table_str[sym]);
    print(" ");

    if (symbol_table_type[sym] == SYMBOL_INT) {
        print("(int)");
        return;
    }
    if (symbol_table_type[sym] == SYMBOL_FUNC) {
        print("(function)");
        return;
    }
    print("???");
}

print_symbols: () -> void = {
    scope := 0;

    while (scope < scope_sz) {
        syms := scope_syms[scope];
        println("Scope", scope, ":");

        i := 0;
        while (i < scope_szs[scope]) {
            sym := syms[i];
            print("  ");
            print_symbol(sym);
            println();

            i += 1;
        }

        scope += 1;
    }
}

main: () -> void = {
    EOF = 255;

    read_content();

    lex_init();
    parser_init();
    string_table_init();

    root := parse();

    symbol_table_init();

    resolve_symbols(root);

    //print_symbols();

    //print_tree(root, 0);

    generate_code(root);

    delete(buf);
}
