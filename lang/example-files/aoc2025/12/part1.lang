min: (x: int, y: int) -> int = {
    if (y < x) return y;
    return x;
}

shape: int[6, 8, 3, 3];
numshape: int[6];
shapesize: int[6];
rotmap: int[9];

type State = struct {
    n:    int;
    m:    int;
    rem: *int;
};

state_create: () -> *State = {
    s := alloc(State);
    s.rem = alloc(int, 6);
    return s;
}

state_destroy: (state: **State) -> void = {
    st := state.*;
    delete(st.rem);
    delete(st);
}

readline: (f: File, buf: *char) -> int = {
    tot := 0;
    for (;;) {
        n := file_read(f, buf, 1);
        if (n == 0) {
            return tot;
        }
        if (buf.* == '\n') {
            buf.* = '\0';
            return tot + 1;
        }
        tot += n;
        buf += n;
    }
    println("Unreachable");
    exit(1);
    return -1;
}

readshape: (idx: int, infile: File, buf: *char) -> void = {
    readline(infile, buf);
    for (i := 0; i < 3; i += 1) {
        readline(infile, buf);
        for (j := 0; j < 3; j += 1) {
            if (buf[j] == '#') {
                shape[idx, 0, i, j] = 1;
            }
        }
    }
    readline(infile, buf);

    // rotations
    for (v := 1; v < 4; v += 1) {
        // 012    630
        // 345 -> 741
        // 678    852
        for (i := 0; i < 3; i += 1) {
            for (j := 0; j < 3; j += 1) {
                id := i * 3 + j;
                roti := rotmap[id] / 3;
                rotj := rotmap[id] % 3;
                shape[idx, v, i, j] = shape[idx, v - 1, roti, rotj];
            }
        }
    }

    // reflections
    for (v := 4; v < 8; v += 1) {
        for (i := 0; i < 3; i += 1) {
            for (j := 0; j < 3; j += 1) {
                shape[idx, v, i, j] = shape[idx, v - 4, i, 2 - j];
            }
        }
    }

    seen := alloc(bool, 1024);
    sptr := 0;
    size := 0;
    for (v := 0; v < 8; v += 1) {
        pw := 1;
        size = 0;
        for (i := 0; i < 3; i += 1) {
            for (j := 0; j < 3; j += 1) {
                pw *= 2;
                pw += shape[idx, v, i, j];
                size += shape[idx, v, i, j];
            }
        }
        if (!seen[pw]) {
            swapshape(idx, sptr, v);
            sptr += 1;
        }
        seen[pw] = true;
    }

    delete(seen);
    numshape[idx] = sptr;
    shapesize[idx] = size;
}

swapshape: (idx: int, v1: int, v2: int) -> void = {
    if (v1 == v2) return;

    for (i := 0; i < 3; i += 1) {
        for (j := 0; j < 3; j += 1) {
            shape[idx, v1, i, j] = shape[idx, v2, i, j];
        }
    }
}

nstoi: (buf: *char, n: int) -> int = {
    ret := 0;
    for (i := 0; i < n; i += 1) {
        ret *= 10;
        ret += cast(int, buf[i]) - cast(int, '0');
    }
    return ret;
}

parse_state: (buf: *char) -> *State = {
    state := state_create();
    rem := state.rem;
    i := 0;
    while (buf[i] != 'x')i += 1;
    state.n = nstoi(buf, i);
    buf += i + 1;
    i = 0;
    while (buf[i] != ':') i += 1;
    state.m = nstoi(buf, i);
    buf += i + 1; // point to ' '
    i = 1; // start of num
    for (j := 0; j < 6; j += 1) {
        numstart := i;
        while (buf[i] != ' ' && buf[i] != '\0' && buf[i] != '\n')i += 1;
        rem[j] = nstoi(buf + numstart, i - numstart);
        i += 1;
    }
    return state;
}


print_shapes: () -> void = {
    for (s := 0; s < 6; s += 1) {
        for (i := 0; i < 3; i += 1) {
            for (v := 0; v < numshape[s]; v += 1) {
                for (j := 0; j < 3; j += 1) {
                    print(shape[s, v, i, j]);
                }
                print(" ");
            }
            println();
        }
        println();
    }
}

// Ensure:
//  n >= m
state_normalize: (state: *State) -> void = {
    if (state.n < state.m) {
        state.m ^= state.n;
        state.n ^= state.m;
        state.m ^= state.n;
    }
}

state_sumrem: (state: *State) -> int = {
    rem := state.rem;
    ret := 0;
    for (i := 0; i < 6; i += 1) {
        ret += rem[i];
    }
    return ret;
}

state_sumpcrem: (state: *State) -> int = {
    rem := state.rem;
    ret := 0;
    for (i := 0; i < 6; i += 1) {
        ret += rem[i] * shapesize[i];
    }
    return ret;
}

printgrid: (grid: **int, rows: int, cols: int) -> void = {
    for (i := 0; i < rows; i += 1) {
        for (j := 0; j  <cols; j += 1) {
            print(grid[i][j]);
        }
        println();
    }
}

resetgrid: (grid: **int, rows: int, cols: int) -> void = {
    for (i := 0; i < rows; i += 1) {
        for (j := 0; j < cols; j += 1) {
            grid[i][j] = 0;
        }
    }
}

dfs_solve: (state: *State, grid: **int, num_placed: int) -> bool = {
    rowz := true;
    for (j := 0; j < state.m; j += 1) {
        if (grid[0][j] == 1) {
            rowz = false;
            break;
        }
    }
    maxr := 5;
    if (num_placed >= 2) {
        for (i := 0; i < 6; i += 1) {
            for (j := 0; j < state.m; j += 1) {
                if (grid[i][j] == 1) {
                    maxr = i;
                }
            }
        }
    }
    maxr = min(maxr, state.n - 1);

    rem := state.rem;
    for (s := 0; s < 6; s += 1) {
        if (rem[s] == 0) continue;
        for (v := 0; v < numshape[s]; v += 1) {
            for (i := 0; i < 3; i += 1) {
                if (i > 0 && rowz) break;
                for (j := 0; j < state.m - 2; j += 1) {
                    works := true;
                    for (y := 0; y < 3; y += 1) {
                        for (x := 0; x < 3; x += 1) {
                            if (grid[i+y][j+x] == 1 && shape[s, v, y, x] == 1) {
                                works = false;
                                break;
                            }
                            if (shape[s, v, y, x] == 1 && i + y > maxr) {
                                works = false;
                                break;
                            }
                        }
                    }
                    if (!works) {
                        continue;
                    }
                    cur := false;
                    for (y := 0; y < 3; y += 1) {
                        for (x := 0; x < 3; x += 1) {
                            if (shape[s, v, y, x] == 1) {
                                grid[i+y][j+x] = 1;
                            }
                        }
                    }

                    // I think WLOG top left corner should be filled
                    if (grid[0][0] > 0) {
                        rem[s] -= 1;
                        cur = dfs_solve(state, grid, num_placed + 1);
                        rem[s] += 1;
                    }

                    for (y := 0; y < 3; y += 1) {
                        for (x := 0; x < 3; x += 1) {
                            if (shape[s, v, y, x] == 1) {
                                grid[i+y][j+x] = 0;
                            }
                        }
                    }

                    if (cur) {
                        return true;
                    }

                    if (works) {
                        // no point in leaving gaps
                        break;
                    }
                }
            }
        }
    }

    remember_n := state.n;
    remember_m := state.m;
    state.n -= maxr + 1;
    ret := solve(state);
    state.n = remember_n;
    state.m = remember_m;
    return ret;
}

solve: (state: *State) -> bool = {
    state_normalize(state);

    srem     := state_sumrem(state);
    sumpcrem := state_sumpcrem(state);

    if (sumpcrem > state.n * state.m) {
        return false;
    }

    if (srem * 9 <= (state.n / 3) * 3 * (state.m / 3) * 3) {
        return true;
    }

    if (state.m < 3) {
        return false;
    }

    // 6 x m working grid
    working_grid := alloc(*int, 6);
    for (i := 0; i < 6; i += 1) {
        working_grid[i] = alloc(int, state.m);
    }

    ret := dfs_solve(state, working_grid, 0);

    for (i := 0; i < 6; i += 1) {
        delete(working_grid[i]);
    }
    delete(working_grid);

    return ret;
}

pre: () -> void = {
    rotmap[0] = 6;
    rotmap[1] = 3;
    rotmap[2] = 0;
    rotmap[3] = 7;
    rotmap[4] = 4;
    rotmap[5] = 1;
    rotmap[6] = 8;
    rotmap[7] = 5;
    rotmap[8] = 2;
}

main: (argc: int, argv: **char) -> void = {
    pre();
    if (argc != 2) {
        println("Missing argument <file>");
        exit(1);
    }

    infile := file_open(argv[1], "r");
    if (cast(int, infile) == 0) {
        println("Failed to open file");
        return;
    }

    buf := alloc(char, 512);
    for (i := 0; i < 6; i += 1) {
        readshape(i, infile, buf);
    }

    ans := 0;
    while (true) {
        nread := readline(infile, buf);
        if (nread == 0) break;

        state := parse_state(buf);

        ret := solve(state);
        if (ret) ans += 1;
        state_destroy(*state);
    }

    println(ans);

    file_close(infile);
    delete(buf);
}
