btns: int[20];
A: int[20, 20];
b: int[20];
npiv: int;
rows: int;
cols: int;
pivcols: int[20];
pivrows: int[20];
ispiv: bool[20];
solval: int[20];
bestsolve: int;
sumsolve: int;

p2: (x: int) -> int = {
    val := 1;
    for (i := 0; i < x; i += 1) {
        val *= 2;
    }
    return val;
}

parse_button: (buf: *char) -> int = {
    btn_val := 0;
    for (ptr := buf + 1; ptr.* != ')';) {
        nxt_ptr := ptr;
        val := 0;
        for (; nxt_ptr.* != ',' && nxt_ptr.* != ')'; nxt_ptr += 1) { 
            val *= 10;
            val += cast(int, nxt_ptr.*) - cast(int, '0');
        }
        btn_val += p2(val);

        ptr = nxt_ptr;
        if (ptr.* == ',') ptr += 1;
    }
    return btn_val;
}

parse_b: (buf: *char) -> void = {
    i := 0;
    for (ptr := buf + 1; ptr.* != '}';) {
        nxt_ptr: *char;
        val := 0;
        for (nxt_ptr = ptr; nxt_ptr.* != ',' && nxt_ptr.* != '}'; nxt_ptr += 1) {
            val *= 10;
            val += cast(int, nxt_ptr.*) - cast(int, '0');
        }
        b[i] = val;
        i += 1;
        ptr = nxt_ptr;
        if (ptr.* == ',')ptr += 1;
    }
}

search: (idx: int) -> int = {
    if (sumsolve > bestsolve) {
        return 10000000;
    }
    if (idx < 0) {
        if (sumsolve < bestsolve) {
            bestsolve = sumsolve;
        }
        return sumsolve;
    }
    if (ispiv[idx]) {
        row := pivrows[idx];
        // A[row, idx] * thisval == A[row, cols] - sum others
        rhs := A[row, cols];
        for (j := idx + 1; j < cols; j += 1) {
            rhs -= A[row, j] * solval[j];
        }
        if (rhs % A[row,idx] != 0) {
            return 10000000;
        }
        thisval := rhs / A[row, idx];
        if (thisval < 0) {
            return 10000000;
        }
        solval[idx] = thisval;
        sumsolve += thisval;
        ret := search(idx - 1);
        sumsolve -= thisval;
        return ret;
    } else {
        ret := 10000000;
        for (val := 0; val < 300; val += 1) {
            solval[idx] = val;
            sumsolve += val;
            cur := search(idx - 1);
            sumsolve -= val;
            if (cur < ret) {
                ret = cur;
            }
        }
        return ret;
    }
    return 10000000;
}

solve_line: (line: *char) -> int = {
    goal_state := 0;

    ptr := line + 1;
    mul := 1;
    num_lgt := 0;
    for (i := 0; ptr.* != ']'; {i += 1; ptr += 1;}) {
        if (ptr.* == '#') {
            goal_state += mul;
        }
        mul *= 2;
        num_lgt += 1;
    }
    num_btn := 0;
    for (; ptr.* != '{'; ptr += 1) {
        if (ptr.* == '(') {
            btns[num_btn] = parse_button(ptr);
            num_btn += 1;
        }
    }

    parse_b(ptr);

    for (i := 0; i < num_lgt; i += 1) {
        for (j := 0; j < num_btn; j += 1) {
            // determine if jth btn has ith bit set
            x := btns[j];
            for (k := 0; k < i; k += 1) {
                x /= 2;
            }
            A[i, j] = x % 2;
        }
        A[i, num_btn] = b[i];
    }


    rows = num_lgt;
    cols = num_btn;
    pivr := 0;
    npiv = 0;
    for (j := 0; j < cols; j += 1) {
        ispiv[j] = false;
    }
    for (piv := 0; piv < cols; piv += 1) {
        nonz_row := -1;
        for (i := pivr; i < rows; i += 1) {
            if (A[i, piv] != 0) {
                nonz_row = i;
                break;
            }
        }
        if (nonz_row == -1) continue;
        // this row needs to move to pivr
        if (nonz_row != pivr) {
            // swap
            for (j := 0; j <= cols; j += 1) {
                A[pivr, j]     ^= A[nonz_row, j];
                A[nonz_row, j] ^= A[pivr, j];
                A[pivr, j]     ^= A[nonz_row, j];
            }
        }
        if (A[pivr, piv] < 0) {
            for (j := 0; j <= cols; j += 1) {
                A[pivr, j] *= -1;
            }
        }
        for (i := pivr + 1; i < rows; i += 1) {
            if (A[i, piv] != 0) {
                // A[i, piv] -> 0
                // 0 = A[i, piv] - x * A[nonz_row, piv]
                // x = A[i, piv] / A[nonz_row, piv]
                // A[i, j] -= A[i, piv] / A[nonz_row, piv] * A[nonz_row, j]
                for (j := 0; j <= cols; j += 1) {
                    A[i,j] *= A[pivr, piv];
                }
                for (j := cols; j >= 0; j -= 1) {
                    val := A[pivr, j] * A[i, piv] / A[pivr, piv];
                    A[i, j] -= val;
                }
            }
        }
        pivcols[npiv] = piv;
        pivrows[piv] = pivr;
        ispiv[piv] = true;
        npiv += 1;
        pivr += 1;
    }
    sumsolve = 0;
    bestsolve = 10000000;
    ans := search(cols - 1);

    return ans;
}

readline: (f: File, buf: *char) -> int = {
    tot := 0;
    for (;;) {
        n := file_read(f, buf, 1);
        if (n == 0) {
            return tot;
        }
        if (buf.* == '\n') {
            buf.* = '\0';
            return tot + 1;
        }
        tot += n;
        buf += n;
    }
    println("Unreachable");
    exit(1);
    return -1;
}

main: (argc: int, argv: **char) -> void = {
    if (argc != 2) {
        println("Missing argument <file>");
        exit(1);
    }

    infile := file_open(argv[1], "r");
    if (cast(int, infile) == 0) {
        println("Failed to open file");
        return;
    }

    buf := alloc(char, 512);
    ans := 0;
    for (;;) {
        nread := readline(infile, buf);
        if (nread == 0) break;
        ans += solve_line(buf);
    }
    file_close(infile);
    delete(buf);

    println(ans);
}
