type Pair = struct {
    x: int;
    y: int;
};

pairs: Pair[500];

max: (x: int, y: int) -> int = {
    if (x > y) return x;
    return y;
}

abs: (x: int) -> int = {
    if (x < 0)return -x;
    return x;
}

readline: (f: File, buf: *char) -> int = {
    tot := 0;
    for (;;) {
        n := file_read(f, buf, 1);
        if (n == 0) {
            return tot;
        }
        if (buf.* == '\n') {
            buf.* = '\0';
            return tot + 1;
        }
        tot += n;
        buf += n;
    }
    println("Unreachable");
    exit(1);
    return -1;
}

parse_pair: (buf: *char, pair_idx: int) -> void = {
    for (i := 0; i < 2; i += 1) {
        val := 0;

        while (buf.* != ',' && buf.* != '\0') {
            val *= 10;
            val += cast(int, buf.*) - cast(int, '0');
            buf += 1;
        }
        if (i == 0) pairs[pair_idx].x = val;
        if (i == 1) {
            pairs[pair_idx].y = val;
            break;
        }
        buf += 1;
    }
}


main: (argc: int, argv: **char) -> void = {
    if (argc < 2) {
        println("Missing input");
        return;
    }

    infile := file_open(argv[1], "r");
    if (cast(int, infile) == 0) {
        println("Failed to open file");
        return;
    }

    n := 0;
    buf := alloc(char, 200);

    for (;;) {
        nread := readline(infile, buf);
        if (nread == 0) break;

        parse_pair(buf, n);
        n += 1;
    }
    file_close(infile);
    delete(buf);

    ans := 0;
    for (i := 0; i < n; i += 1) {
        for (j := i + 1; j < n; j += 1) {
            dx := abs(pairs[i].x - pairs[j].x) + 1;
            dy := abs(pairs[i].y - pairs[j].y) + 1;
            area := dx * dy;
            ans = max(ans, area);
        }
    }
    println(ans);
}
