type Pair = struct {
    x: int;
    y: int;
};

type Seg = struct {
    xl: int;
    xr: int;
    yl: int;
    yh: int;
};

pairs: Pair[500];
segs: Seg[500];
yval: int[100000];
mxy: int = 99999;
tree_min: int[400000];
tree_max: int[400000];

max: (x: int, y: int) -> int = {
    if (x > y) return x;
    return y;
}

min: (x: int, y: int) -> int = {
    if (x < y) return x;
    return y;
}

abs: (x: int) -> int = {
    if (x < 0)return -x;
    return x;
}

readline: (f: File, buf: *char) -> int = {
    tot := 0;
    for (;;) {
        n := file_read(f, buf, 1);
        if (n == 0) {
            return tot;
        }
        if (buf.* == '\n') {
            buf.* = '\0';
            return tot + 1;
        }
        tot += n;
        buf += n;
    }
    println("Unreachable");
    exit(1);
    return -1;
}

parse_pair: (buf: *char, pair_idx: int) -> void = {
    for (i := 0; i < 2; i += 1) {
        val := 0;

        while (buf.* != ',' && buf.* != '\0') {
            val *= 10;
            val += cast(int, buf.*) - cast(int, '0');
            buf += 1;
        }
        if (i == 0) pairs[pair_idx].x = val;
        if (i == 1) {
            pairs[pair_idx].y = val;
            break;
        }
        buf += 1;
    }
}

seg_swap: (i: int, j: int) -> void = {
    if (i == j) return;

    segs[i].xl ^= segs[j].xl;
    segs[j].xl ^= segs[i].xl;
    segs[i].xl ^= segs[j].xl;

    segs[i].xr ^= segs[j].xr;
    segs[j].xr ^= segs[i].xr;
    segs[i].xr ^= segs[j].xr;

    segs[i].yl ^= segs[j].yl;
    segs[j].yl ^= segs[i].yl;
    segs[i].yl ^= segs[j].yl;

    segs[i].yh ^= segs[j].yh;
    segs[j].yh ^= segs[i].yh;
    segs[i].yh ^= segs[j].yh;
}

quick_sort: (l: int, r: int) -> void = {
    if (l >= r) {
        return;
    }

    piv := (l+r)/2;
    seg_swap(piv, r);
    px := segs[r].xl;
    py := segs[r].yl;
    i := l - 1;
    j := l;

    while (j < r) {
        if (segs[j].xl < px || (segs[j].xl == px && segs[j].yl < py) || (segs[j].xl == px && segs[j].yl == py && segs[j].yl != segs[j].yh)) {
            i += 1;
            seg_swap(j, i);
        }
        j += 1;
    }

    seg_swap(r, i + 1);

    quick_sort(l, i);
    quick_sort(i + 2, r);
}

getarea: (y1: int, y2: int, xl: int, xr: int) -> int = {
    good := true;
    lo := min(y1, y2);
    hi := max(y1, y2);
    if (query_min(1, 0, mxy, lo, hi) == 0) return 0;
    if (query_max(1, 0, mxy, lo, hi) > xl) return 0;
    return (hi - lo + 1) * (xr - xl + 1);
}

query_min: (p: int, l: int, r: int, i: int, j: int) -> int = {
    if (i <= l && r <= j) {
        return tree_min[p];
    }
    if (j < l || r < i) {
        return 1000000000;
    }

    mid := (l + r) / 2;
    lft := 2 * p;
    rgt := 2 * p + 1;
    return min(query_min(lft, l, mid, i, j), query_min(rgt, mid + 1, r, i, j));
}

query_max: (p: int, l: int, r: int, i: int, j: int) -> int = {
    if (i <= l && r <= j) {
        return tree_max[p];
    }
    if (j < l || r < i) {
        return 0;
    }

    mid := (l + r) / 2;
    lft := 2 * p;
    rgt := 2 * p + 1;
    return max(query_max(lft, l, mid, i, j), query_max(rgt, mid + 1, r, i, j));
}

update_point: (p: int, l: int, r: int, idx: int, val: int) -> void = {
    if (idx < l || r < idx) {
        return;
    }
    if (l == r) {
        yval[idx] = val;
        tree_min[p] = val;
        tree_max[p] = val;
        return;
    }

    mid := (l + r) / 2;
    lft := 2 * p;
    rgt := 2 * p + 1;
    if (idx <= mid) {
        update_point(lft, l, mid, idx, val);
    } else {
        update_point(rgt, mid + 1, r, idx, val);
    }
    tree_min[p] = min(tree_min[lft], tree_min[rgt]);
    tree_max[p] = max(tree_max[lft], tree_max[rgt]);
}

main: (argc: int, argv: **char) -> void = {
    if (argc < 2) {
        println("Missing input");
        return;
    }

    infile := file_open(argv[1], "r");
    if (cast(int, infile) == 0) {
        println("Failed to open file");
        return;
    }

    n := 0;
    buf := alloc(char, 200);

    for (;;) {
        nread := readline(infile, buf);
        if (nread == 0) break;

        parse_pair(buf, n);
        n += 1;
    }
    file_close(infile);
    delete(buf);

    nseg := 0;

    for (i := 0; i < n; i += 1) {
        nxt := (i + 1) % n;

        if (pairs[i].x == pairs[nxt].x) {
            yl := min(pairs[i].y, pairs[nxt].y);
            yh := max(pairs[i].y, pairs[nxt].y);
            segs[nseg].xl = pairs[i].x;
            segs[nseg].xr = pairs[i].x;
            segs[nseg].yl = yl;
            segs[nseg].yh = yh;
            nseg += 1;
        } else {
            xl := min(pairs[i].x, pairs[nxt].x);
            xr := max(pairs[i].x, pairs[nxt].x);
            segs[nseg].xl = xl;
            segs[nseg].xr = xr;
            segs[nseg].yl = pairs[i].y;
            segs[nseg].yh = pairs[i].y;
            nseg += 1;
        }
    }

    quick_sort(0, nseg - 1);

    ans := 0;
    for (i := 0; i < nseg; i += 1) {
        if (segs[i].xl == segs[i].xr) {
            for (j := 0; j < i; j += 1) {
               if (segs[j].xl != segs[j].xr) continue;
               // jl <-> il, jl <-> ih, jh <-> il, jh <-> ih
               ans = max(ans, getarea(segs[j].yl, segs[i].yl, segs[j].xl, segs[i].xl));
               ans = max(ans, getarea(segs[j].yl, segs[i].yh, segs[j].xl, segs[i].xl));
               ans = max(ans, getarea(segs[j].yh, segs[i].yl, segs[j].xl, segs[i].xl));
               ans = max(ans, getarea(segs[j].yh, segs[i].yh, segs[j].xl, segs[i].xl));
            }

            for (y := segs[i].yl + 1; y < segs[i].yh; y += 1) {
                if (yval[y] == 0) {
                    update_point(1, 0, mxy, y, segs[i].xl);
                } else {
                    update_point(1, 0, mxy, y, 0);
                }
            }
        } else {
            if (yval[segs[i].yl] == 0) {
                update_point(1, 0, mxy, segs[i].yl, segs[i].xl);
            } else {
                update_point(1, 0, mxy, segs[i].yl, 0);
            }
        }
    }

    println(ans);
}
