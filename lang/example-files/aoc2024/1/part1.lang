token_size: int;
buf: char[100];
EOF: char;

// epic
read_token_buf: () -> void = {
    token_size = 0;
    c: char;

    while (true) {
        c = readchar();

        // rip || operator
        flag: bool = false;
        if (c == ' ') { flag = true; }
        if (c == '\n') { flag = true; }
        if (c == '\t') { flag = true; }

        if (!flag) {
            break;
        }
    }

    if (c == EOF) {
        return;
    }

    buf[token_size] = c;
    token_size += 1;

    while (true) {
        c = readchar();

        if (c == EOF) {
            break;
        }

        // need some OR
        if (c == ' ') { break; }
        if (c == '\n') { break; }
        if (c == '\t') { break; }

        buf[token_size] = c;
        token_size += 1;
    }
}

tokentoll : () -> int = {
    i := 0;
    ret := 0;

    while (i < token_size) {
        ret *= 10;

        dig := cast(int, buf[i] - '0');
        ret += dig;
        i += 1;
    }

    return ret;
}

// Bruh sort
sort: (a: *int, n: int) -> void = {
    start := 0;
    while (start < n) {
        minidx := start;

        i := start + 1;

        while (i < n) {
            if (a[i] < a[minidx]) {
                minidx = i;
            }

            i += 1;
        }

        tmp := a[start];
        a[start] = a[minidx];
        a[minidx] = tmp;

        start += 1;
    }
}

abs: (a: int) -> int = {
    if (a < 0) {
        return -a;
    }
    return a;
}

main: () -> void =  {
    // hehe
    EOF = cast(char, 255);

    arr1 := alloc(int, 1024);
    arr2 := alloc(int, 1024);

    n := 0;
    while (true) {
        // read first token B-)
        read_token_buf();

        if (token_size == 0) {
            break;
        }

        arr1[n] = tokentoll();

        read_token_buf();

        arr2[n] = tokentoll();

        n += 1;
    }

    sort(arr1, n);
    sort(arr2, n);

    ans := 0;

    i := 0;
    while (i < n) {
        ans += abs(arr1[i] - arr2[i]);
        i += 1;
    }

    println(ans);

    delete(arr1);
    delete(arr2);
}
